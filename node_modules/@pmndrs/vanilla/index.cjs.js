"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("three"),t=require("three/examples/jsm/postprocessing/Pass"),n=require("three/examples/jsm/utils/BufferGeometryUtils"),r=require("troika-three-text");function o(e){if(e&&e.__esModule)return e;var t=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var r=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(t,n,r.get?r:{enumerable:!0,get:function(){return e[n]}})}})),t.default=e,Object.freeze(t)}var a=o(e);function i(e,t,n,r){const o=Object.entries(e);class i extends a.ShaderMaterial{constructor(e){super({uniforms:o.reduce(((e,[t,n])=>({...e,...a.UniformsUtils.clone({[t]:{value:n}})})),{}),vertexShader:t,fragmentShader:n});for(const[e]of o)Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t});Object.assign(this,e),null==r||r(this)}}return i.key=a.MathUtils.generateUUID(),i}function s(e=1024,t=1024,n={samples:0,depth:!1}){var r=e,o=t,i=n,s=i.samples||0,l=i.depth,c=Object.assign({},i);delete c.samples,delete c.depth;var u=new a.WebGLRenderTarget(r,o,Object.assign({minFilter:a.LinearFilter,magFilter:a.LinearFilter,type:a.HalfFloatType},c));return l&&(u.depthTexture=new a.DepthTexture(r,o,a.FloatType)),u.samples=s,u}function l(e=a.FrontSide){const t={value:new a.Matrix4};return Object.assign(new a.MeshNormalMaterial({side:e}),{viewMatrix:t,onBeforeCompile:e=>{e.uniforms.viewMatrix=t,e.fragmentShader="vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n           return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n         }\n"+e.fragmentShader.replace("#include <normal_fragment_maps>","#include <normal_fragment_maps>\n           normal = inverseTransformDirection( normal, viewMatrix );\n")}})}const c=i({causticsTexture:null,causticsTextureB:null,color:new a.Color,lightProjMatrix:new a.Matrix4,lightViewMatrix:new a.Matrix4},"varying vec3 vWorldPosition;   \n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vec4 worldPosition = modelMatrix * vec4(position, 1.);\n     vWorldPosition = worldPosition.xyz;\n   }",`varying vec3 vWorldPosition;\n  uniform vec3 color;\n  uniform sampler2D causticsTexture; \n  uniform sampler2D causticsTextureB; \n  uniform mat4 lightProjMatrix;\n  uniform mat4 lightViewMatrix;\n   void main() {\n    // Apply caustics  \n    vec4 lightSpacePos = lightProjMatrix * lightViewMatrix * vec4(vWorldPosition, 1.0);\n    lightSpacePos.xyz /= lightSpacePos.w;\n    lightSpacePos.xyz = lightSpacePos.xyz * 0.5 + 0.5; \n    vec3 front = texture2D(causticsTexture, lightSpacePos.xy).rgb;\n    vec3 back = texture2D(causticsTextureB, lightSpacePos.xy).rgb;\n    gl_FragColor = vec4((front + back) * color, 1.0);\n    #include <tonemapping_fragment>\n    #include <${parseInt(a.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`),u=i({cameraMatrixWorld:new a.Matrix4,cameraProjectionMatrixInv:new a.Matrix4,normalTexture:null,depthTexture:null,lightDir:new a.Vector3(0,1,0),lightPlaneNormal:new a.Vector3(0,1,0),lightPlaneConstant:0,near:.1,far:100,modelMatrix:new a.Matrix4,worldRadius:1/40,ior:1.1,bounces:0,resolution:1024,size:10,intensity:.5},"\n  varying vec2 vUv;\n  void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n  }","  \n  uniform mat4 cameraMatrixWorld;\n  uniform mat4 cameraProjectionMatrixInv;\n  uniform vec3 lightDir;\n  uniform vec3 lightPlaneNormal;\n  uniform float lightPlaneConstant;\n  uniform float near;\n  uniform float far;\n  uniform float time;\n  uniform float worldRadius;\n  uniform float resolution;\n  uniform float size;\n  uniform float intensity;\n  uniform float ior;\n  precision highp isampler2D;\n  precision highp usampler2D;\n  uniform sampler2D normalTexture;\n  uniform sampler2D depthTexture;\n  uniform float bounces;\n  varying vec2 vUv;\n  vec3 WorldPosFromDepth(float depth, vec2 coord) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(coord * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraProjectionMatrixInv * clipSpacePosition;\n    // Perspective division\n    viewSpacePosition /= viewSpacePosition.w;\n    vec4 worldSpacePosition = cameraMatrixWorld * viewSpacePosition;\n    return worldSpacePosition.xyz;\n  }                  \n  float sdPlane( vec3 p, vec3 n, float h ) {\n    // n must be normalized\n    return dot(p,n) + h;\n  }\n  float planeIntersect( vec3 ro, vec3 rd, vec4 p ) {\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n  }\n  vec3 totalInternalReflection(vec3 ro, vec3 rd, vec3 pos, vec3 normal, float ior, out vec3 rayOrigin, out vec3 rayDirection) {\n    rayOrigin = ro;\n    rayDirection = rd;\n    rayDirection = refract(rayDirection, normal, 1.0 / ior);\n    rayOrigin = pos + rayDirection * 0.1;\n    return rayDirection;\n  }\n  void main() {\n    // Each sample consists of random offset in the x and y direction\n    float caustic = 0.0;\n    float causticTexelSize = (1.0 / resolution) * size * 2.0;\n    float texelsNeeded = worldRadius / causticTexelSize;\n    float sampleRadius = texelsNeeded / resolution;\n    float sum = 0.0;\n    if (texture2D(depthTexture, vUv).x == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec2 offset1 = vec2(-0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset2 = vec2(-0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset3 = vec2(0.5, 0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 offset4 = vec2(0.5, -0.5);//vec2(rand() - 0.5, rand() - 0.5);\n    vec2 uv1 = vUv + offset1 * sampleRadius;\n    vec2 uv2 = vUv + offset2 * sampleRadius;\n    vec2 uv3 = vUv + offset3 * sampleRadius;\n    vec2 uv4 = vUv + offset4 * sampleRadius;\n    vec3 normal1 = texture2D(normalTexture, uv1, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal2 = texture2D(normalTexture, uv2, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal3 = texture2D(normalTexture, uv3, -10.0).rgb * 2.0 - 1.0;\n    vec3 normal4 = texture2D(normalTexture, uv4, -10.0).rgb * 2.0 - 1.0;\n    float depth1 = texture2D(depthTexture, uv1, -10.0).x;\n    float depth2 = texture2D(depthTexture, uv2, -10.0).x;\n    float depth3 = texture2D(depthTexture, uv3, -10.0).x;\n    float depth4 = texture2D(depthTexture, uv4, -10.0).x;\n    // Sanity check the depths\n    if (depth1 == 1.0 || depth2 == 1.0 || depth3 == 1.0 || depth4 == 1.0) {\n      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n      return;\n    }\n    vec3 pos1 = WorldPosFromDepth(depth1, uv1);\n    vec3 pos2 = WorldPosFromDepth(depth2, uv2);\n    vec3 pos3 = WorldPosFromDepth(depth3, uv3);\n    vec3 pos4 = WorldPosFromDepth(depth4, uv4);\n    vec3 originPos1 = WorldPosFromDepth(0.0, uv1);\n    vec3 originPos2 = WorldPosFromDepth(0.0, uv2);\n    vec3 originPos3 = WorldPosFromDepth(0.0, uv3);\n    vec3 originPos4 = WorldPosFromDepth(0.0, uv4);\n    vec3 endPos1, endPos2, endPos3, endPos4;\n    vec3 endDir1, endDir2, endDir3, endDir4;\n    totalInternalReflection(originPos1, lightDir, pos1, normal1, ior, endPos1, endDir1);\n    totalInternalReflection(originPos2, lightDir, pos2, normal2, ior, endPos2, endDir2);\n    totalInternalReflection(originPos3, lightDir, pos3, normal3, ior, endPos3, endDir3);\n    totalInternalReflection(originPos4, lightDir, pos4, normal4, ior, endPos4, endDir4);\n    float lightPosArea = length(cross(originPos2 - originPos1, originPos3 - originPos1)) + length(cross(originPos3 - originPos1, originPos4 - originPos1));\n    float t1 = planeIntersect(endPos1, endDir1, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t2 = planeIntersect(endPos2, endDir2, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t3 = planeIntersect(endPos3, endDir3, vec4(lightPlaneNormal, lightPlaneConstant));\n    float t4 = planeIntersect(endPos4, endDir4, vec4(lightPlaneNormal, lightPlaneConstant));\n    vec3 finalPos1 = endPos1 + endDir1 * t1;\n    vec3 finalPos2 = endPos2 + endDir2 * t2;\n    vec3 finalPos3 = endPos3 + endDir3 * t3;\n    vec3 finalPos4 = endPos4 + endDir4 * t4;\n    float finalArea = length(cross(finalPos2 - finalPos1, finalPos3 - finalPos1)) + length(cross(finalPos3 - finalPos1, finalPos4 - finalPos1));\n    caustic += intensity * (lightPosArea / finalArea);\n    // Calculate the area of the triangle in light spaces\n    gl_FragColor = vec4(vec3(max(caustic, 0.0)), 1.0);\n  }"),d={depth:!0,minFilter:a.LinearFilter,magFilter:a.LinearFilter,type:a.UnsignedByteType},m={minFilter:a.LinearMipmapLinearFilter,magFilter:a.LinearFilter,type:a.FloatType,generateMipmaps:!0},f=i({},"void main() { }","void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");const h=i({color:new a.Color(0),blend:2,alphaTest:.75,opacity:0,map:null},"varying vec2 vUv;\n   void main() {\n     gl_Position = projectionMatrix * viewMatrix * modelMatrix * vec4(position, 1.);\n     vUv = uv;\n   }",`varying vec2 vUv;\n   uniform sampler2D map;\n   uniform vec3 color;\n   uniform float opacity;\n   uniform float alphaTest;\n   uniform float blend;\n   void main() {\n     vec4 sampledDiffuseColor = texture2D(map, vUv);\n     gl_FragColor = vec4(color * sampledDiffuseColor.r * blend, max(0.0, (1.0 - (sampledDiffuseColor.r + sampledDiffuseColor.g + sampledDiffuseColor.b) / alphaTest)) * opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(a.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`);const p=(e,t)=>{"updateRanges"in e?e.updateRanges[0]=t:e.updateRange=t},v=new e.Matrix4,g=new e.Vector3,x=new e.Quaternion,w=new e.Vector3,y=new e.Quaternion,S=new e.Vector3,M=t=>class extends t{constructor(){super();const t=parseInt(e.REVISION.replace(/\D+/g,""))>=154?"opaque_fragment":"output_fragment";this.onBeforeCompile=e=>{e.vertexShader="attribute float opacity;\n               varying float vOpacity;\n              "+e.vertexShader.replace("#include <fog_vertex>","#include <fog_vertex>\n                 vOpacity = opacity;\n                "),e.fragmentShader="varying float vOpacity;\n              "+e.fragmentShader.replace(`#include <${t}>`,`#include <${t}>\n                 gl_FragColor = vec4(outgoingLight, diffuseColor.a * vOpacity);\n                `)}}};class _ extends e.Group{constructor({limit:t=200,range:n,material:r=e.MeshLambertMaterial,texture:o,frustumCulled:a=!0}={}){super(),this.name="Clouds",this.ref=this;const i=new e.PlaneGeometry(1,1),s=new Float32Array(Array.from({length:t},(()=>1))),l=new Float32Array(Array.from({length:t},(()=>[1,1,1])).flat()),c=new e.InstancedBufferAttribute(s,1);c.setUsage(e.DynamicDrawUsage),i.setAttribute("opacity",c);const u=new(M(r));u.map=o,u.transparent=!0,u.depthWrite=!1,u.needsUpdate=!0,this.cloudMaterial=u,this.instance=new e.InstancedMesh(i,u,t);const d=this.instance;d.matrixAutoUpdate=!1,d.frustumCulled=a,d.instanceColor=new e.InstancedBufferAttribute(l,3),d.instanceColor.setUsage(e.DynamicDrawUsage),this.add(d);const m=[],f=()=>{const e=m.length;let t=0;for(let e=0;e<this.ref.children.length;e++){const n=this.ref.children[e];n.cloudStateArray&&(t+=n.cloudStateArray.length)}if(e===t)return m;m.length=0;for(let e=0;e<this.ref.children.length;e++){const t=this.ref.children[e];t.cloudStateArray&&m.push(...t.cloudStateArray)}return h(),m},h=()=>{const e=Math.min(t,void 0!==n?n:t,m.length);d.count=e,p(d.instanceMatrix,{offset:0,count:16*e}),d.instanceColor&&p(d.instanceColor,{offset:0,count:3*e}),p(d.geometry.attributes.opacity,{offset:0,count:e})};let _,D=0,b=0;const T=new e.Quaternion,P=new e.Vector3(0,0,1),C=new e.Vector3;this.update=(e,t,n)=>{D=t,v.copy(d.matrixWorld).invert(),e.matrixWorld.decompose(w,y,S);const r=f();for(b=0;b<r.length;b++)_=r[b],_.ref.matrixWorld.decompose(g,x,S),g.add(C.copy(_.position).applyQuaternion(x).multiply(S)),x.copy(y).multiply(T.setFromAxisAngle(P,_.rotation+=n*_.rotationFactor)),S.multiplyScalar(_.volume+(1+Math.sin(D*_.density*_.speed))/2*_.growth),_.matrix.compose(g,x,S).premultiply(v),_.dist=g.distanceTo(w);for(r.sort(((e,t)=>t.dist-e.dist)),b=0;b<r.length;b++)_=r[b],s[b]=_.opacity*(_.dist<_.fade-1?_.dist/_.fade:1),d.setMatrixAt(b,_.matrix),d.setColorAt(b,_.color);d.geometry.attributes.opacity.needsUpdate=!0,d.instanceMatrix.needsUpdate=!0,d.instanceColor&&(d.instanceColor.needsUpdate=!0)}}}let D=0;class b extends e.Group{constructor({opacity:t=1,speed:n=0,bounds:r=(new e.Vector3).fromArray([5,1,1]),segments:o=20,color:a=new e.Color("#ffffff"),fade:i=10,volume:s=6,smallestVolume:l=.25,distribute:c=null,growth:u=4,concentrate:d="inside",seed:m=Math.random()}={}){super(),this.name="cloud_"+D++,this.seed=m,this.segments=o,this.bounds=r,this.concentrate=d,this.volume=s,this.smallestVolume=l,this.distribute=c,this.growth=u,this.speed=n,this.fade=i,this.opacity=t,this.color=a,this.ref=this,this.cloudStateArray=[],this.updateCloud()}updateCloudStateArray(){if(this.cloudStateArray.length===this.segments)return;const{segments:t,uuid:n}=this;if(this.cloudStateArray.length>this.segments)this.cloudStateArray.splice(0,this.cloudStateArray.length-this.segments);else for(let r=this.cloudStateArray.length;r<t;r++)this.cloudStateArray.push({segments:t,bounds:new e.Vector3(1,1,1),position:new e.Vector3,uuid:n,index:r,ref:this,dist:0,matrix:new e.Matrix4,volume:0,length:0,speed:0,growth:0,opacity:1,fade:0,density:0,rotation:r*(Math.PI/t),rotationFactor:0,color:new e.Color})}updateCloud(){const{volume:e,color:t,speed:n,growth:r,opacity:o,fade:a,bounds:i,seed:s,cloudStateArray:l,distribute:c,segments:u,concentrate:d,smallestVolume:m}=this;this.updateCloudStateArray();let f=0;function h(){const e=1e4*Math.sin(s+f);return f++,e-Math.floor(e)}l.forEach(((s,l)=>{s.segments=u,s.volume=e,s.color=t,s.speed=n,s.growth=r,s.opacity=o,s.fade=a,s.bounds.copy(i),s.density=Math.max(.5,h()),s.rotationFactor=Math.max(.2,.5*h())*n;const f=null==c?void 0:c(s,l);var p;(f||u>1)&&s.position.copy(s.bounds).multiply(null!==(p=null==f?void 0:f.point)&&void 0!==p?p:{x:2*h()-1,y:2*h()-1,z:2*h()-1});const v=Math.abs(s.position.x),g=Math.abs(s.position.y),x=Math.abs(s.position.z),w=Math.max(v,g,x);s.length=1,v===w&&(s.length-=v/s.bounds.x),g===w&&(s.length-=g/s.bounds.y),x===w&&(s.length-=x/s.bounds.z),s.volume=(void 0!==(null==f?void 0:f.volume)?f.volume:Math.max(Math.max(0,m),"random"===d?h():"inside"===d?s.length:1-s.length))*e}))}}const T=i({screenspace:!1,color:new a.Color("black"),opacity:1,thickness:.05,size:new a.Vector2},"\n   #include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   uniform float screenspace;\n   uniform vec2 size;\n   void main() {\n     #if defined (USE_SKINNING)\n\t   #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 tNormal = vec4(normal, 0.0);\n     vec4 tPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       tNormal = instanceMatrix * tNormal;\n       tPosition = instanceMatrix * tPosition;\n     #endif\n     if (screenspace == 0.0) {\n       vec3 newPosition = tPosition.xyz + tNormal.xyz * thickness;\n       gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n     } else {\n       vec4 clipPosition = projectionMatrix * modelViewMatrix * tPosition;\n       vec4 clipNormal = projectionMatrix * modelViewMatrix * tNormal;\n       vec2 offset = normalize(clipNormal.xy) * thickness / size * clipPosition.w * 2.0;\n       clipPosition.xy += offset;\n       gl_Position = clipPosition;\n     }\n   }",`\n   uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(a.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n   }`);const P=["onSync","onPreloadEnd","characters"];function C(e){return Object.keys(e).reduce(((t,n)=>(-1===P.indexOf(n)&&(t[n]=e[n]),t)),{})}const F=i({alphaTest:0,viewport:new a.Vector2(1980,1080),focal:1e3,centerAndScaleTexture:null,covAndColorTexture:null},"\n    precision highp sampler2D;\n    precision highp usampler2D;\n    out vec4 vColor;\n    out vec3 vPosition;\n    uniform vec2 resolution;\n    uniform vec2 viewport;\n    uniform float focal;\n    attribute uint splatIndex;\n    uniform sampler2D centerAndScaleTexture;\n    uniform usampler2D covAndColorTexture;    \n\n    vec2 unpackInt16(in uint value) {\n      int v = int(value);\n      int v0 = v >> 16;\n      int v1 = (v & 0xFFFF);\n      if((v & 0x8000) != 0)\n        v1 |= 0xFFFF0000;\n      return vec2(float(v1), float(v0));\n    }\n\n    void main () {\n      ivec2 texSize = textureSize(centerAndScaleTexture, 0);\n      ivec2 texPos = ivec2(splatIndex%uint(texSize.x), splatIndex/uint(texSize.x));\n      vec4 centerAndScaleData = texelFetch(centerAndScaleTexture, texPos, 0);\n      vec4 center = vec4(centerAndScaleData.xyz, 1);\n      vec4 camspace = modelViewMatrix * center;\n      vec4 pos2d = projectionMatrix * camspace;\n\n      float bounds = 1.2 * pos2d.w;\n      if (pos2d.z < -pos2d.w || pos2d.x < -bounds || pos2d.x > bounds\n        || pos2d.y < -bounds || pos2d.y > bounds) {\n        gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n        return;\n      }\n\n      uvec4 covAndColorData = texelFetch(covAndColorTexture, texPos, 0);\n      vec2 cov3D_M11_M12 = unpackInt16(covAndColorData.x) * centerAndScaleData.w;\n      vec2 cov3D_M13_M22 = unpackInt16(covAndColorData.y) * centerAndScaleData.w;\n      vec2 cov3D_M23_M33 = unpackInt16(covAndColorData.z) * centerAndScaleData.w;\n      mat3 Vrk = mat3(\n        cov3D_M11_M12.x, cov3D_M11_M12.y, cov3D_M13_M22.x,\n        cov3D_M11_M12.y, cov3D_M13_M22.y, cov3D_M23_M33.x,\n        cov3D_M13_M22.x, cov3D_M23_M33.x, cov3D_M23_M33.y\n      );\n\n      mat3 J = mat3(\n        focal / camspace.z, 0., -(focal * camspace.x) / (camspace.z * camspace.z),\n        0., focal / camspace.z, -(focal * camspace.y) / (camspace.z * camspace.z),\n        0., 0., 0.\n      );\n\n      mat3 W = transpose(mat3(modelViewMatrix));\n      mat3 T = W * J;\n      mat3 cov = transpose(T) * Vrk * T;\n      vec2 vCenter = vec2(pos2d) / pos2d.w;\n      float diagonal1 = cov[0][0] + 0.3;\n      float offDiagonal = cov[0][1];\n      float diagonal2 = cov[1][1] + 0.3;\n      float mid = 0.5 * (diagonal1 + diagonal2);\n      float radius = length(vec2((diagonal1 - diagonal2) / 2.0, offDiagonal));\n      float lambda1 = mid + radius;\n      float lambda2 = max(mid - radius, 0.1);\n      vec2 diagonalVector = normalize(vec2(offDiagonal, lambda1 - diagonal1));\n      vec2 v1 = min(sqrt(2.0 * lambda1), 1024.0) * diagonalVector;\n      vec2 v2 = min(sqrt(2.0 * lambda2), 1024.0) * vec2(diagonalVector.y, -diagonalVector.x);\n      uint colorUint = covAndColorData.w;\n      vColor = vec4(\n        float(colorUint & uint(0xFF)) / 255.0,\n        float((colorUint >> uint(8)) & uint(0xFF)) / 255.0,\n        float((colorUint >> uint(16)) & uint(0xFF)) / 255.0,\n        float(colorUint >> uint(24)) / 255.0\n      );\n      vPosition = position;\n\n      gl_Position = vec4(\n        vCenter \n          + position.x * v2 / viewport * 2.0 \n          + position.y * v1 / viewport * 2.0, pos2d.z / pos2d.w, 1.0);\n    }\n    ",`\n    #include <alphatest_pars_fragment>\n    #include <alphahash_pars_fragment>\n    in vec4 vColor;\n    in vec3 vPosition;\n    void main () {\n      float A = -dot(vPosition.xy, vPosition.xy);\n      if (A < -4.0) discard;\n      float B = exp(A) * vColor.a;\n      vec4 diffuseColor = vec4(vColor.rgb, B);\n      #include <alphatest_fragment>\n      #include <alphahash_fragment>\n      gl_FragColor = diffuseColor;\n      #include <tonemapping_fragment>\n      #include <${parseInt(a.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n    }\n  `);function A(e){let t=null,n=0;e.onmessage=r=>{if("push"==r.data.method){0===n&&(t=new Float32Array(r.data.length));const e=new Float32Array(r.data.matrices);t.set(e,n),n+=e.length}else if("sort"==r.data.method&&null!==t){const n=function(e,n=!1){const r=t.length/16;let o=-1/0,a=1/0;const i=new Float32Array(r),s=new Int32Array(i.buffer),l=new Int32Array(r);let c=0;for(let s=0;s<r;s++){const r=e[0]*t[16*s+12]+e[1]*t[16*s+13]+e[2]*t[16*s+14]+e[3];(n||r<0&&t[16*s+15]>-1e-4*r)&&(i[c]=r,l[c]=s,c++,r>o&&(o=r),r<a&&(a=r))}const u=65535/(o-a),d=new Uint32Array(65536);for(let e=0;e<c;e++)s[e]=(i[e]-a)*u|0,d[s[e]]++;const m=new Uint32Array(65536);for(let e=1;e<65536;e++)m[e]=m[e-1]+d[e-1];const f=new Uint32Array(c);for(let e=0;e<c;e++)f[m[s[e]]++]=l[e];return f}(new Float32Array(r.data.view),r.data.hashed);e.postMessage({indices:n,key:r.data.key},[n.buffer])}}}class B extends a.Loader{constructor(e,t=25e3){super(),this.gl=e,this.chunkSize=t}async loadAsync(e,t,n){return new Promise((r=>this.load(e,r,t,n)))}load(e,t,n,r){const o={gl:this.gl,url:this.manager.resolveURL(e),worker:new Worker(URL.createObjectURL(new Blob(["(",A.toString(),")(self)"],{type:"application/javascript"}))),manager:this.manager,update:(e,t,n)=>function(e,t,n,r){if(e.updateMatrixWorld(),t.gl.getCurrentViewport(n.viewport),n.material.viewport.x=n.viewport.z,n.material.viewport.y=n.viewport.w,n.material.focal=n.viewport.w/2*Math.abs(e.projectionMatrix.elements[5]),n.ready){if(r&&n.sorted)return;n.ready=!1;const e=new Float32Array([n.modelViewMatrix.elements[2],-n.modelViewMatrix.elements[6],n.modelViewMatrix.elements[10],n.modelViewMatrix.elements[14]]);t.worker.postMessage({method:"sort",src:t.url,key:n.uuid,view:e.buffer,hashed:r},[e.buffer]),r&&t.loaded&&(n.sorted=!0)}}(t,o,e,n),connect:e=>function(e,t){e.loading||async function(e){e.loading=!0;let t=0,n=0;const r=[];let o=0;const a=0!==e.totalDownloadBytes;for(;;)try{const{value:i,done:s}=await e.stream.read();if(s)break;if(t+=i.length,null!=e.totalDownloadBytes){const n=t/e.totalDownloadBytes*100;if(e.onProgress&&n-o>1){const r=new ProgressEvent("progress",{lengthComputable:a,loaded:t,total:e.totalDownloadBytes});e.onProgress(r),o=n}}r.push(i);const l=t-n;if(null!=e.totalDownloadBytes&&l>e.rowLength*e.chunkSize){const t=Math.floor(l/e.rowLength),o=new Uint8Array(l);let i=0;for(const e of r)o.set(e,i),i+=e.length;if(r.length=0,l>t*e.rowLength){const n=new Uint8Array(l-t*e.rowLength);n.set(o.subarray(l-n.length,l),0),r.push(n)}const s=new Uint8Array(t*e.rowLength);s.set(o.subarray(0,s.byteLength),0);const c=U(e,s.buffer,t);if(e.worker.postMessage({method:"push",src:e.url,length:16*e.numVertices,matrices:c.buffer},[c.buffer]),n+=t*e.rowLength,e.onProgress){const t=new ProgressEvent("progress",{lengthComputable:a,loaded:e.totalDownloadBytes,total:e.totalDownloadBytes});e.onProgress(t)}}}catch(e){console.error(e);break}if(t-n>0){const t=new Uint8Array(r.reduce(((e,t)=>e+t.length),0));let n=0;for(const e of r)t.set(e,n),n+=e.length;const o=Math.floor(t.byteLength/e.rowLength),a=U(e,t.buffer,o);e.worker.postMessage({method:"push",src:e.url,length:16*o,matrices:a.buffer},[a.buffer])}e.loaded=!0,e.manager.itemEnd(e.url)}(e);t.ready=!1,t.pm=new a.Matrix4,t.vm1=new a.Matrix4,t.vm2=new a.Matrix4,t.viewport=new a.Vector4;const n=new Uint32Array(e.bufferTextureWidth*e.bufferTextureHeight),r=new a.InstancedBufferAttribute(n,1,!1);r.setUsage(a.DynamicDrawUsage);const o=t.geometry=new a.InstancedBufferGeometry,i=new Float32Array(18),s=new a.BufferAttribute(i,3);function l(e){if(t&&e.data.key===t.uuid){const n=new Uint32Array(e.data.indices);o.attributes.splatIndex.set(n),o.attributes.splatIndex.needsUpdate=!0,o.instanceCount=n.length,t.ready=!0}}async function c(){for(;;){const t=e.gl.properties.get(e.centerAndScaleTexture),n=e.gl.properties.get(e.covAndColorTexture);if(null!=t&&t.__webglTexture&&null!=n&&n.__webglTexture&&e.loadedVertexCount>0)break;await new Promise((e=>setTimeout(e,10)))}t.ready=!0}return o.setAttribute("position",s),s.setXYZ(2,-2,2,0),s.setXYZ(1,2,2,0),s.setXYZ(0,-2,-2,0),s.setXYZ(5,-2,-2,0),s.setXYZ(4,2,2,0),s.setXYZ(3,2,-2,0),s.needsUpdate=!0,o.setAttribute("splatIndex",r),o.instanceCount=1,e.worker.addEventListener("message",l),c(),()=>e.worker.removeEventListener("message",l)}(o,e),loading:!1,loaded:!1,loadedVertexCount:0,chunkSize:this.chunkSize,totalDownloadBytes:0,numVertices:0,rowLength:32,maxVertexes:0,bufferTextureWidth:0,bufferTextureHeight:0,stream:null,centerAndScaleData:null,covAndColorData:null,covAndColorTexture:null,centerAndScaleTexture:null,onProgress:n};(async function(e){e.manager.itemStart(e.url);const t=await fetch(e.url);if(null===t.body)throw"Failed to fetch file";const n=t.headers.get("Content-Length"),r=n?parseInt(n):void 0;if(null==r)throw"Failed to get content length";e.stream=t.body.getReader(),e.totalDownloadBytes=r,e.numVertices=Math.floor(e.totalDownloadBytes/e.rowLength);const o=e.gl.getContext(),i=o.getParameter(o.MAX_TEXTURE_SIZE);e.maxVertexes=i*i,e.numVertices>e.maxVertexes&&(e.numVertices=e.maxVertexes);return e.bufferTextureWidth=i,e.bufferTextureHeight=Math.floor((e.numVertices-1)/i)+1,e.centerAndScaleData=new Float32Array(e.bufferTextureWidth*e.bufferTextureHeight*4),e.covAndColorData=new Uint32Array(e.bufferTextureWidth*e.bufferTextureHeight*4),e.centerAndScaleTexture=new a.DataTexture(e.centerAndScaleData,e.bufferTextureWidth,e.bufferTextureHeight,a.RGBAFormat,a.FloatType),e.centerAndScaleTexture.needsUpdate=!0,e.covAndColorTexture=new a.DataTexture(e.covAndColorData,e.bufferTextureWidth,e.bufferTextureHeight,a.RGBAIntegerFormat,a.UnsignedIntType),e.covAndColorTexture.internalFormat="RGBA32UI",e.covAndColorTexture.needsUpdate=!0,e})(o).then(t).catch((e=>{null==r||r(e),o.manager.itemError(o.url)}))}}function U(e,t,n){const r=e.gl.getContext();if(e.loadedVertexCount+n>e.maxVertexes&&(n=e.maxVertexes-e.loadedVertexCount),n<=0)throw"Failed to parse file";const o=new Uint8Array(t),i=new Float32Array(t),s=new Float32Array(16*n),l=new Uint8Array(e.covAndColorData.buffer),c=new Int16Array(e.covAndColorData.buffer);for(let t=0;t<n;t++){const n=new a.Quaternion(-(o[32*t+28+1]-128)/128,(o[32*t+28+2]-128)/128,(o[32*t+28+3]-128)/128,-(o[32*t+28+0]-128)/128);n.invert();const r=new a.Vector3(i[8*t+0],i[8*t+1],-i[8*t+2]),u=new a.Vector3(i[8*t+3+0],i[8*t+3+1],i[8*t+3+2]),d=new a.Matrix4;d.makeRotationFromQuaternion(n),d.transpose(),d.scale(u);const m=d.clone();d.transpose(),d.premultiply(m),d.setPosition(r);const f=[0,1,2,5,6,10];let h=0;for(let e=0;e<f.length;e++)Math.abs(d.elements[f[e]])>h&&(h=Math.abs(d.elements[f[e]]));let p=4*e.loadedVertexCount+4*t;e.centerAndScaleData[p+0]=r.x,e.centerAndScaleData[p+1]=-r.y,e.centerAndScaleData[p+2]=r.z,e.centerAndScaleData[p+3]=h/32767,p=8*e.loadedVertexCount+4*t*2;for(let e=0;e<f.length;e++)c[p+e]=32767*d.elements[f[e]]/h;p=16*e.loadedVertexCount+4*(4*t+3);const v=new a.Color(o[32*t+24+0]/255,o[32*t+24+1]/255,o[32*t+24+2]/255);v.convertSRGBToLinear(),l[p+0]=255*v.r,l[p+1]=255*v.g,l[p+2]=255*v.b,l[p+3]=o[32*t+24+3],d.elements[15]=Math.max(u.x,u.y,u.z)*o[32*t+24+3]/255;for(let e=0;e<16;e++)s[16*t+e]=d.elements[e]}for(;n>0;){let t=0,o=0;const a=e.loadedVertexCount%e.bufferTextureWidth,i=Math.floor(e.loadedVertexCount/e.bufferTextureWidth);e.loadedVertexCount%e.bufferTextureWidth!=0?(t=Math.min(e.bufferTextureWidth,a+n)-a,o=1):Math.floor(n/e.bufferTextureWidth)>0?(t=e.bufferTextureWidth,o=Math.floor(n/e.bufferTextureWidth)):(t=n%e.bufferTextureWidth,o=1);const s=e.gl.properties.get(e.centerAndScaleTexture);r.bindTexture(r.TEXTURE_2D,s.__webglTexture),r.texSubImage2D(r.TEXTURE_2D,0,a,i,t,o,r.RGBA,r.FLOAT,e.centerAndScaleData,4*e.loadedVertexCount);const l=e.gl.properties.get(e.covAndColorTexture);r.bindTexture(r.TEXTURE_2D,l.__webglTexture),r.texSubImage2D(r.TEXTURE_2D,0,a,i,t,o,r.RGBA_INTEGER,r.UNSIGNED_INT,e.covAndColorData,4*e.loadedVertexCount),e.gl.resetState(),e.loadedVertexCount+=t*o,n-=t*o}return s}class z extends a.Mesh{constructor(e,t,{toneMapped:n=!1,alphaTest:r=0,alphaHash:o=!1}={}){super(),this.frustumCulled=!1,this.onBeforeRender=()=>e.update(this,t,o),this.material=new F,Object.assign(this.material,{transparent:!o,depthTest:!0,alphaTest:o?0:r,centerAndScaleTexture:e.centerAndScaleTexture,covAndColorTexture:e.covAndColorTexture,depthWrite:!!o||r>0,blending:o?a.NormalBlending:a.CustomBlending,blendSrcAlpha:a.OneFactor,alphaHash:!!o,toneMapped:n}),e.connect(this)}}const R=i({cellSize:.5,sectionSize:1,fadeDistance:100,fadeStrength:1,cellThickness:.5,sectionThickness:1,cellColor:new a.Color,sectionColor:new a.Color,infiniteGrid:!1,followCamera:!1,worldCamProjPosition:new a.Vector3,worldPlanePosition:new a.Vector3},"\n      varying vec3 localPosition;\n      varying vec4 worldPosition;\n  \n      uniform vec3 worldCamProjPosition;\n      uniform vec3 worldPlanePosition;\n      uniform float fadeDistance;\n      uniform bool infiniteGrid;\n      uniform bool followCamera;\n  \n      void main() {\n        localPosition = position.xzy;\n        if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n        \n        worldPosition = modelMatrix * vec4(localPosition, 1.0);\n        if (followCamera) {\n          worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n          localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n        }\n  \n        gl_Position = projectionMatrix * viewMatrix * worldPosition;\n      }\n    ",`\n      varying vec3 localPosition;\n      varying vec4 worldPosition;\n  \n      uniform vec3 worldCamProjPosition;\n      uniform float cellSize;\n      uniform float sectionSize;\n      uniform vec3 cellColor;\n      uniform vec3 sectionColor;\n      uniform float fadeDistance;\n      uniform float fadeStrength;\n      uniform float cellThickness;\n      uniform float sectionThickness;\n  \n      float getGrid(float size, float thickness) {\n        vec2 r = localPosition.xz / size;\n        vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n        float line = min(grid.x, grid.y) + 1.0 - thickness;\n        return 1.0 - min(line, 1.0);\n      }\n  \n      void main() {\n        float g1 = getGrid(cellSize, cellThickness);\n        float g2 = getGrid(sectionSize, sectionThickness);\n  \n        float dist = distance(worldCamProjPosition, worldPosition.xyz);\n        float d = 1.0 - min(dist / fadeDistance, 1.0);\n        vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n  \n        gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n        gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n        if (gl_FragColor.a <= 0.0) discard;\n  \n        #include <tonemapping_fragment>\n        #include <${parseInt(a.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n      }\n    `);class k extends a.MeshPhysicalMaterial{constructor({samples:e=6,transmissionSampler:t=!1,chromaticAberration:n=.05,transmission:r=0,_transmission:o=1,transmissionMap:i=null,roughness:s=0,thickness:l=0,thicknessMap:c=null,attenuationDistance:u=1/0,attenuationColor:d=new a.Color("white"),anisotropicBlur:m=.1,time:f=0,distortion:h=0,distortionScale:p=.5,temporalDistortion:v=0,buffer:g=null}={}){super(),this.uniforms={chromaticAberration:{value:n},transmission:{value:r},_transmission:{value:o},transmissionMap:{value:i},roughness:{value:s},thickness:{value:l},thicknessMap:{value:c},attenuationDistance:{value:u},attenuationColor:{value:d},anisotropicBlur:{value:m},time:{value:f},distortion:{value:h},distortionScale:{value:p},temporalDistortion:{value:v},buffer:{value:g}},this.onBeforeCompile=n=>{n.uniforms={...n.uniforms,...this.uniforms},t?n.defines.USE_SAMPLER="":n.defines.USE_TRANSMISSION="",n.fragmentShader="\n      uniform float chromaticAberration;         \n      uniform float anisotropicBlur;      \n      uniform float time;\n      uniform float distortion;\n      uniform float distortionScale;\n      uniform float temporalDistortion;\n      uniform sampler2D buffer;\n\n      vec3 random3(vec3 c) {\n        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n        vec3 r;\n        r.z = fract(512.0*j);\n        j *= .125;\n        r.x = fract(512.0*j);\n        j *= .125;\n        r.y = fract(512.0*j);\n        return r-0.5;\n      }\n\n      uint hash( uint x ) {\n        x += ( x << 10u );\n        x ^= ( x >>  6u );\n        x += ( x <<  3u );\n        x ^= ( x >> 11u );\n        x += ( x << 15u );\n        return x;\n      }\n\n      // Compound versions of the hashing algorithm I whipped together.\n      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }\n      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }\n      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }\n\n      // Construct a float with half-open range [0:1] using low 23 bits.\n      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.\n      float floatConstruct( uint m ) {\n        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask\n        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32\n        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)\n        m |= ieeeOne;                          // Add fractional part to 1.0\n        float  f = uintBitsToFloat( m );       // Range [1:2]\n        return f - 1.0;                        // Range [0:1]\n      }\n\n      // Pseudo-random value in half-open range [0:1].\n      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }\n      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }\n      float rand(float seed) {\n        float result = randomBase(vec3(gl_FragCoord.xy, seed));\n        return result;\n      }\n\n      const float F3 =  0.3333333;\n      const float G3 =  0.1666667;\n\n      float snoise(vec3 p) {\n        vec3 s = floor(p + dot(p, vec3(F3)));\n        vec3 x = p - s + dot(s, vec3(G3));\n        vec3 e = step(vec3(0.0), x - x.yzx);\n        vec3 i1 = e*(1.0 - e.zxy);\n        vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n        vec3 x1 = x - i1 + G3;\n        vec3 x2 = x - i2 + 2.0*G3;\n        vec3 x3 = x - 1.0 + 3.0*G3;\n        vec4 w, d;\n        w.x = dot(x, x);\n        w.y = dot(x1, x1);\n        w.z = dot(x2, x2);\n        w.w = dot(x3, x3);\n        w = max(0.6 - w, 0.0);\n        d.x = dot(random3(s), x);\n        d.y = dot(random3(s + i1), x1);\n        d.z = dot(random3(s + i2), x2);\n        d.w = dot(random3(s + 1.0), x3);\n        w *= w;\n        w *= w;\n        d *= w;\n        return dot(d, vec4(52.0));\n      }\n\n      float snoiseFractal(vec3 m) {\n        return 0.5333333* snoise(m)\n              +0.2666667* snoise(2.0*m)\n              +0.1333333* snoise(4.0*m)\n              +0.0666667* snoise(8.0*m);\n      }\n"+n.fragmentShader,n.fragmentShader=n.fragmentShader.replace("#include <transmission_pars_fragment>","\n        #ifdef USE_TRANSMISSION\n          // Transmission code is based on glTF-Sampler-Viewer\n          // https://github.com/KhronosGroup/glTF-Sample-Viewer\n          uniform float _transmission;\n          uniform float thickness;\n          uniform float attenuationDistance;\n          uniform vec3 attenuationColor;\n          #ifdef USE_TRANSMISSIONMAP\n            uniform sampler2D transmissionMap;\n          #endif\n          #ifdef USE_THICKNESSMAP\n            uniform sampler2D thicknessMap;\n          #endif\n          uniform vec2 transmissionSamplerSize;\n          uniform sampler2D transmissionSamplerMap;\n          uniform mat4 modelMatrix;\n          uniform mat4 projectionMatrix;\n          varying vec3 vWorldPosition;\n          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n            // Direction of refracted light.\n            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n            // Compute rotation-independant scaling of the model matrix.\n            vec3 modelScale;\n            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n            // The thickness is specified in local space.\n            return normalize( refractionVector ) * thickness * modelScale;\n          }\n          float applyIorToRoughness( const in float roughness, const in float ior ) {\n            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and\n            // an IOR of 1.5 results in the default amount of microfacet refraction.\n            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n          }\n          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            \n            #ifdef USE_SAMPLER\n              #ifdef texture2DLodEXT\n                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #else\n                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);\n              #endif\n            #else\n              return texture2D(buffer, fragCoord.xy);\n            #endif\n          }\n          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n            if ( isinf( attenuationDistance ) ) {\n              // Attenuation distance is +∞, i.e. the transmitted color is not attenuated at all.\n              return radiance;\n            } else {\n              // Compute light attenuation using Beer's law.\n              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law\n              return transmittance * radiance;\n            }\n          }\n          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n            const in vec3 attenuationColor, const in float attenuationDistance ) {\n            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n            vec3 refractedRayExit = position + transmissionRay;\n            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.\n            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n            vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n            refractionCoords += 1.0;\n            refractionCoords /= 2.0;\n            // Sample framebuffer to get pixel the refracted ray hits.\n            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n            // Get the specular component.\n            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n          }\n        #endif\n"),n.fragmentShader=n.fragmentShader.replace("#include <transmission_fragment>",`  \n        // Improve the refraction to use the world pos\n        material.transmission = _transmission;\n        material.transmissionAlpha = 1.0;\n        material.thickness = thickness;\n        material.attenuationDistance = attenuationDistance;\n        material.attenuationColor = attenuationColor;\n        #ifdef USE_TRANSMISSIONMAP\n          material.transmission *= texture2D( transmissionMap, vUv ).r;\n        #endif\n        #ifdef USE_THICKNESSMAP\n          material.thickness *= texture2D( thicknessMap, vUv ).g;\n        #endif\n        \n        vec3 pos = vWorldPosition;\n        float runningSeed = 0.0;\n        vec3 v = normalize( cameraPosition - pos );\n        vec3 n = inverseTransformDirection( normal, viewMatrix );\n        vec3 transmission = vec3(0.0);\n        float transmissionR, transmissionB, transmissionG;\n        float randomCoords = rand(runningSeed++);\n        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);\n        vec3 distortionNormal = vec3(0.0);\n        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;\n        if (distortion > 0.0) {\n          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));\n        }\n        for (float i = 0.0; i < ${e}.0; i ++) {\n          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);\n          transmissionR = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).r;\n          transmissionG = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).g;\n          transmissionB = getIBLVolumeRefraction(\n            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),\n            material.attenuationColor, material.attenuationDistance\n          ).b;\n          transmission.r += transmissionR;\n          transmission.g += transmissionG;\n          transmission.b += transmissionB;\n        }\n        transmission /= ${e}.0;\n        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );\n`)},Object.keys(this.uniforms).forEach((e=>Object.defineProperty(this,e,{get:()=>this.uniforms[e].value,set:t=>this.uniforms[e].value=t})))}}const I=i({depth:null,opacity:1,attenuation:2.5,anglePower:12,spotPosition:new e.Vector3(0,0,0),lightColor:new e.Color("white"),cameraNear:0,cameraFar:1,resolution:new e.Vector2(0,0),transparent:!0,depthWrite:!1},"\n  varying vec3 vNormal;\n  varying vec3 vWorldPosition;\n  varying float vViewZ;\n  varying float vIntensity;\n  uniform vec3 spotPosition;\n  uniform float attenuation;\n\n  void main() {\n    // compute intensity\n    vNormal = normalize( normalMatrix * normal );\n    vec4 worldPosition\t= modelMatrix * vec4( position, 1.0 );\n    vWorldPosition = worldPosition.xyz;\n    vec4 viewPosition = viewMatrix * worldPosition;\n    vViewZ = viewPosition.z;\n    float intensity\t= distance(worldPosition.xyz, spotPosition) / attenuation;\n    intensity\t= 1.0 - clamp(intensity, 0.0, 1.0);\n    vIntensity = intensity;\n    // set gl_Position\n    gl_Position\t= projectionMatrix * viewPosition;\n\n  }",`\n  #include <packing>\n\n  varying vec3 vNormal;\n  varying vec3 vWorldPosition;\n  uniform vec3 lightColor;\n  uniform vec3 spotPosition;\n  uniform float attenuation;\n  uniform float anglePower;\n  uniform sampler2D depth;\n  uniform vec2 resolution;\n  uniform float cameraNear;\n  uniform float cameraFar;\n  varying float vViewZ;\n  varying float vIntensity;\n  uniform float opacity;\n\n  float readDepth( sampler2D depthSampler, vec2 coord ) {\n    float fragCoordZ = texture2D( depthSampler, coord ).x;\n    float viewZ = perspectiveDepthToViewZ(fragCoordZ, cameraNear, cameraFar);\n    return viewZ;\n  }\n\n  void main() {\n    float d = 1.0;\n    bool isSoft = resolution[0] > 0.0 && resolution[1] > 0.0;\n    if (isSoft) {\n      vec2 sUv = gl_FragCoord.xy / resolution;\n      d = readDepth(depth, sUv);\n    }\n    float intensity = vIntensity;\n    vec3 normal\t= vec3(vNormal.x, vNormal.y, abs(vNormal.z));\n    float angleIntensity\t= pow( dot(normal, vec3(0.0, 0.0, 1.0)), anglePower );\n    intensity\t*= angleIntensity;\n    // fades when z is close to sampled depth, meaning the cone is intersecting existing geometry\n    if (isSoft) {\n      intensity\t*= smoothstep(0., 1., vViewZ - d);\n    }\n    gl_FragColor = vec4(lightColor, intensity * opacity);\n\n    #include <tonemapping_fragment>\n    #include <${parseInt(e.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n  }`);class V extends e.ShaderMaterial{constructor(t=new e.Vector2){super({uniforms:{inputBuffer:new e.Uniform(null),depthBuffer:new e.Uniform(null),resolution:new e.Uniform(new e.Vector2),texelSize:new e.Uniform(new e.Vector2),halfTexelSize:new e.Uniform(new e.Vector2),kernel:new e.Uniform(0),scale:new e.Uniform(1),cameraNear:new e.Uniform(0),cameraFar:new e.Uniform(1),minDepthThreshold:new e.Uniform(0),maxDepthThreshold:new e.Uniform(1),depthScale:new e.Uniform(0),depthToBlurRatioBias:new e.Uniform(.25)},fragmentShader:`#include <common>\n        #include <dithering_pars_fragment>      \n        uniform sampler2D inputBuffer;\n        uniform sampler2D depthBuffer;\n        uniform float cameraNear;\n        uniform float cameraFar;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          float depthFactor = 0.0;\n          \n          #ifdef USE_DEPTH\n            vec4 depth = texture2D(depthBuffer, vUv);\n            depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n            depthFactor *= depthScale;\n            depthFactor = max(0.0, min(1.0, depthFactor + 0.25));\n          #endif\n          \n          vec4 sum = texture2D(inputBuffer, mix(vUv0, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv1, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv2, vUv, depthFactor));\n          sum += texture2D(inputBuffer, mix(vUv3, vUv, depthFactor));\n          gl_FragColor = sum * 0.25 ;\n\n          #include <dithering_fragment>\n          #include <tonemapping_fragment>\n          #include <${parseInt(e.REVISION.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>\n        }`,vertexShader:"uniform vec2 texelSize;\n        uniform vec2 halfTexelSize;\n        uniform float kernel;\n        uniform float scale;\n        varying vec2 vUv;\n        varying vec2 vUv0;\n        varying vec2 vUv1;\n        varying vec2 vUv2;\n        varying vec2 vUv3;\n\n        void main() {\n          vec2 uv = position.xy * 0.5 + 0.5;\n          vUv = uv;\n\n          vec2 dUv = (texelSize * vec2(kernel) + halfTexelSize) * scale;\n          vUv0 = vec2(uv.x - dUv.x, uv.y + dUv.y);\n          vUv1 = vec2(uv.x + dUv.x, uv.y + dUv.y);\n          vUv2 = vec2(uv.x + dUv.x, uv.y - dUv.y);\n          vUv3 = vec2(uv.x - dUv.x, uv.y - dUv.y);\n\n          gl_Position = vec4(position.xy, 1.0, 1.0);\n        }",blending:e.NoBlending,depthWrite:!1,depthTest:!1}),this.toneMapped=!1,this.setTexelSize(t.x,t.y),this.kernel=new Float32Array([0,1,2,2,3])}setTexelSize(e,t){this.uniforms.texelSize.value.set(e,t),this.uniforms.halfTexelSize.value.set(e,t).multiplyScalar(.5)}setResolution(e){this.uniforms.resolution.value.copy(e)}}class O extends e.MeshStandardMaterial{constructor(e={}){super(),this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this._tDepth={value:null},this._distortionMap={value:null},this._tDiffuse={value:null},this._tDiffuseBlur={value:null},this._textureMatrix={value:null},this._hasBlur={value:!1},this._mirror={value:0},this._mixBlur={value:0},this._blurStrength={value:.5},this._minDepthThreshold={value:.9},this._maxDepthThreshold={value:1},this._depthScale={value:0},this._depthToBlurRatioBias={value:.25},this._distortion={value:1},this._mixContrast={value:1},this.setValues(e)}onBeforeCompile(e){var t;null!=(t=e.defines)&&t.USE_UV||(e.defines.USE_UV=""),e.uniforms.hasBlur=this._hasBlur,e.uniforms.tDiffuse=this._tDiffuse,e.uniforms.tDepth=this._tDepth,e.uniforms.distortionMap=this._distortionMap,e.uniforms.tDiffuseBlur=this._tDiffuseBlur,e.uniforms.textureMatrix=this._textureMatrix,e.uniforms.mirror=this._mirror,e.uniforms.mixBlur=this._mixBlur,e.uniforms.mixStrength=this._blurStrength,e.uniforms.minDepthThreshold=this._minDepthThreshold,e.uniforms.maxDepthThreshold=this._maxDepthThreshold,e.uniforms.depthScale=this._depthScale,e.uniforms.depthToBlurRatioBias=this._depthToBlurRatioBias,e.uniforms.distortion=this._distortion,e.uniforms.mixContrast=this._mixContrast,e.vertexShader=`\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;\n      ${e.vertexShader}`,e.vertexShader=e.vertexShader.replace("#include <project_vertex>","#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );"),e.fragmentShader=`\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float mixContrast;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;\n        ${e.fragmentShader}`,e.fragmentShader=e.fragmentShader.replace("#include <emissivemap_fragment>","#include <emissivemap_fragment>\n\n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n\n      vec4 merge = base;\n\n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);\n        #else\n          merge = merge * depthFactor;\n        #endif\n\n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n\n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      vec4 newMerge = vec4(0.0, 0.0, 0.0, 1.0);\n      newMerge.r = (merge.r - 0.5) * mixContrast + 0.5;\n      newMerge.g = (merge.g - 0.5) * mixContrast + 0.5;\n      newMerge.b = (merge.b - 0.5) * mixContrast + 0.5;\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + newMerge.rgb * mixStrength);\n      ")}get tDiffuse(){return this._tDiffuse.value}set tDiffuse(e){this._tDiffuse.value=e}get tDepth(){return this._tDepth.value}set tDepth(e){this._tDepth.value=e}get distortionMap(){return this._distortionMap.value}set distortionMap(e){this._distortionMap.value=e}get tDiffuseBlur(){return this._tDiffuseBlur.value}set tDiffuseBlur(e){this._tDiffuseBlur.value=e}get textureMatrix(){return this._textureMatrix.value}set textureMatrix(e){this._textureMatrix.value=e}get hasBlur(){return this._hasBlur.value}set hasBlur(e){this._hasBlur.value=e}get mirror(){return this._mirror.value}set mirror(e){this._mirror.value=e}get mixBlur(){return this._mixBlur.value}set mixBlur(e){this._mixBlur.value=e}get mixStrength(){return this._blurStrength.value}set mixStrength(e){this._blurStrength.value=e}get minDepthThreshold(){return this._minDepthThreshold.value}set minDepthThreshold(e){this._minDepthThreshold.value=e}get maxDepthThreshold(){return this._maxDepthThreshold.value}set maxDepthThreshold(e){this._maxDepthThreshold.value=e}get depthScale(){return this._depthScale.value}set depthScale(e){this._depthScale.value=e}get depthToBlurRatioBias(){return this._depthToBlurRatioBias.value}set depthToBlurRatioBias(e){this._depthToBlurRatioBias.value=e}get distortion(){return this._distortion.value}set distortion(e){this._distortion.value=e}get mixContrast(){return this._mixContrast.value}set mixContrast(e){this._mixContrast.value=e}}exports.Billboard=({follow:e=!0,lockX:t=!1,lockY:n=!1,lockZ:r=!1}={})=>{const o=new a.Group,i={follow:e,lockX:t,lockY:n,lockZ:r};return{group:o,update:function(e){const{follow:t,lockX:n,lockY:r,lockZ:a}=i;if(!t)return;const s=o.rotation.clone();e.getWorldQuaternion(o.quaternion),n&&(o.rotation.x=s.x),r&&(o.rotation.y=s.y),a&&(o.rotation.z=s.z)},updateProps(e){Object.assign(i,e)}}},exports.BlurPass=class{constructor({gl:t,resolution:n,width:r=500,height:o=500,minDepthThreshold:a=0,maxDepthThreshold:i=1,depthScale:s=0,depthToBlurRatioBias:l=.25}){this.renderToScreen=!1,this.renderTargetA=new e.WebGLRenderTarget(n,n,{minFilter:e.LinearFilter,magFilter:e.LinearFilter,stencilBuffer:!1,depthBuffer:!1,type:e.HalfFloatType}),this.renderTargetB=this.renderTargetA.clone(),this.convolutionMaterial=new V,this.convolutionMaterial.setTexelSize(1/r,1/o),this.convolutionMaterial.setResolution(new e.Vector2(r,o)),this.scene=new e.Scene,this.camera=new e.Camera,this.convolutionMaterial.uniforms.minDepthThreshold.value=a,this.convolutionMaterial.uniforms.maxDepthThreshold.value=i,this.convolutionMaterial.uniforms.depthScale.value=s,this.convolutionMaterial.uniforms.depthToBlurRatioBias.value=l,this.convolutionMaterial.defines.USE_DEPTH=s>0;const c=new Float32Array([-1,-1,0,3,-1,0,-1,3,0]),u=new Float32Array([0,0,2,0,0,2]),d=new e.BufferGeometry;d.setAttribute("position",new e.BufferAttribute(c,3)),d.setAttribute("uv",new e.BufferAttribute(u,2)),this.screen=new e.Mesh(d,this.convolutionMaterial),this.screen.frustumCulled=!1,this.scene.add(this.screen)}render(e,t,n){const r=this.scene,o=this.camera,a=this.renderTargetA,i=this.renderTargetB,s=this.convolutionMaterial,l=s.uniforms;l.depthBuffer.value=t.depthTexture;const c=s.kernel;let u,d,m,f=t;for(d=0,m=c.length-1;d<m;++d)u=0==(1&d)?a:i,l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(u),e.render(r,o),f=u;l.kernel.value=c[d],l.inputBuffer.value=f.texture,e.setRenderTarget(this.renderToScreen?null:n),e.render(r,o)}},exports.CLOUD_URL="https://rawcdn.githack.com/pmndrs/drei-assets/9225a9f1fbd449d9411125c2f419b843d0308c9f/cloud.png",exports.Caustics=(e,{frames:n=1,causticsOnly:r=!1,ior:o=1.1,backside:i=!1,backsideIOR:f=1.1,worldRadius:h=.3125,color:p=new a.Color("white"),intensity:v=.05,resolution:g=2024,lightSource:x=new a.Vector3(1,1,1),near:w=.1,far:y=0}={})=>{const S={frames:n,ior:o,color:p,causticsOnly:r,backside:i,backsideIOR:f,worldRadius:h,intensity:v,resolution:g,lightSource:x,near:w,far:y},M=new a.Group;M.name="caustics_group";const _=M,D=new a.OrthographicCamera,b=new a.Scene;b.name="caustics_scene";const T=e,P=new a.CameraHelper(D);P.name="caustics_helper";const C=S.resolution,F=s(C,C,d),A=s(C,C,d),B=s(C,C,m),U=s(C,C,m),z=l(),R=l(a.BackSide),k=new u,I=new t.FullScreenQuad(k),V=new a.Mesh(new a.PlaneGeometry(1,1),new c({transparent:!0,color:S.color,causticsTexture:B.texture,causticsTextureB:U.texture,blending:a.CustomBlending,blendSrc:a.OneFactor,blendDst:a.SrcAlphaFactor,depthWrite:!1}));V.name="caustics_plane",V.rotation.x=-Math.PI/2,V.renderOrder=2,M.add(b,V),M.updateWorldMatrix(!1,!0);let O=0;const N=new a.Vector3,E=new a.Frustum,j=new a.Matrix4,L=new a.Plane,W=new a.Vector3,G=new a.Vector3,$=new a.Box3,H=new a.Vector3,Z=[],X=[],Y=[],q=[],Q=new a.Vector3;for(let e=0;e<8;e++)Z.push(new a.Vector3),X.push(new a.Vector3),Y.push(new a.Vector3),q.push(new a.Vector3);return{scene:b,group:M,helper:P,params:S,update:()=>{if(S.frames===1/0||O++<S.frames){var e;(null==(t=x)?void 0:t.isVector3)?W.copy(x).normalize():W.copy(_.worldToLocal(x.getWorldPosition(N)).normalize()),G.copy(W).multiplyScalar(-1),null==(e=b.parent)||e.matrixWorld.identity(),$.setFromObject(b,!0),Z[0].set($.min.x,$.min.y,$.min.z),Z[1].set($.min.x,$.min.y,$.max.z),Z[2].set($.min.x,$.max.y,$.min.z),Z[3].set($.min.x,$.max.y,$.max.z),Z[4].set($.max.x,$.min.y,$.min.z),Z[5].set($.max.x,$.min.y,$.max.z),Z[6].set($.max.x,$.max.y,$.min.z),Z[7].set($.max.x,$.max.y,$.max.z);for(let e=0;e<8;e++)X[e].copy(Z[e]);$.getCenter(H),Z.map((e=>e.sub(H)));const n=L.set(G,0);Z.map(((e,t)=>n.projectPoint(e,Y[t])));const r=Y.reduce(((e,t)=>e.add(t)),N.set(0,0,0)).divideScalar(Y.length),o=Y.map((e=>e.distanceTo(r))).reduce(((e,t)=>Math.max(e,t))),a=Z.map((e=>e.dot(W))).reduce(((e,t)=>Math.max(e,t)));D.position.copy(Q.copy(W).multiplyScalar(a).add(H)),D.lookAt(b.localToWorld(H));const i=j.lookAt(D.position,H,N.set(0,1,0));if(D.left=-o,D.right=o,D.top=o,D.bottom=-o,D.near=S.near,S.far)D.far=S.far;else{const e=N.set(0,o,0).applyMatrix4(i),t=(D.position.y+e.y)/W.y;D.far=t}D.updateProjectionMatrix(),D.updateMatrixWorld();const s=X.map(((e,t)=>e.add(q[t].copy(W).multiplyScalar(-e.y/W.y)))),l=s.reduce(((e,t)=>e.add(t)),N.set(0,0,0)).divideScalar(s.length),c=2*s.map((e=>Math.hypot(e.x-l.x,e.z-l.z))).reduce(((e,t)=>Math.max(e,t)));V.scale.setScalar(c),V.position.copy(l),P.parent&&P.update(),R.viewMatrix.value=z.viewMatrix.value=D.matrixWorldInverse;const u=E.setFromProjectionMatrix(j.multiplyMatrices(D.projectionMatrix,D.matrixWorldInverse)).planes[4];k.cameraMatrixWorld=D.matrixWorld,k.cameraProjectionMatrixInv=D.projectionMatrixInverse,k.lightDir=G,k.lightPlaneNormal=u.normal,k.lightPlaneConstant=u.constant,k.near=D.near,k.far=D.far,k.resolution=S.resolution,k.size=o,k.intensity=S.intensity,k.worldRadius=S.worldRadius,b.visible=!0,T.setRenderTarget(F),T.clear(),b.overrideMaterial=z,T.render(b,D),T.setRenderTarget(A),T.clear(),S.backside&&(b.overrideMaterial=R,T.render(b,D)),b.overrideMaterial=null,k.ior=S.ior,V.material.lightProjMatrix=D.projectionMatrix,V.material.lightViewMatrix=D.matrixWorldInverse,k.normalTexture=F.texture,k.depthTexture=F.depthTexture,T.setRenderTarget(B),T.clear(),I.render(T),k.ior=S.backsideIOR,k.normalTexture=A.texture,k.depthTexture=A.depthTexture,T.setRenderTarget(U),T.clear(),S.backside&&I.render(T),T.setRenderTarget(null),S.causticsOnly&&(b.visible=!1)}var t},normalTarget:F,normalTargetB:A,causticsTarget:B,causticsTargetB:U}},exports.Cloud=b,exports.Clouds=_,exports.ConvolutionMaterial=V,exports.Grid=({args:e=[1,1],cellColor:t=new a.Color("#000000"),sectionColor:n=new a.Color("#2080ff"),cellSize:r=.5,sectionSize:o=1,followCamera:i=!1,infiniteGrid:s=!1,fadeDistance:l=100,fadeStrength:c=1,cellThickness:u=.5,sectionThickness:d=1,side:m=a.BackSide}={})=>{const f=new R({transparent:!0,side:m,...{cellSize:r,sectionSize:o,cellColor:t,sectionColor:n,cellThickness:u,sectionThickness:d},...{fadeDistance:l,fadeStrength:c,infiniteGrid:s,followCamera:i}}),h=new a.PlaneGeometry(e[0],e[1]),p=new a.Mesh(h,f);p.frustumCulled=!1;const v=new a.Plane,g=new a.Vector3(0,1,0),x=new a.Vector3(0,0,0);return{mesh:p,update:e=>{if(!p.parent)return;v.setFromNormalAndCoplanarPoint(g,x).applyMatrix4(p.matrixWorld);const t=p.material,n=t.uniforms.worldCamProjPosition,r=t.uniforms.worldPlanePosition;v.projectPoint(e.position,n.value),r.value.set(0,0,0).applyMatrix4(p.matrixWorld)}}},exports.MeshDiscardMaterial=f,exports.MeshReflectorMaterial=O,exports.MeshTransmissionMaterial=k,exports.Outlines=function({color:e=new a.Color("black"),opacity:t=1,transparent:r=!1,screenspace:o=!1,toneMapped:i=!0,polygonOffset:s=!1,polygonOffsetFactor:l=0,renderOrder:c=0,thickness:u=.05,angle:d=Math.PI,gl:m}){const f=new a.Group;let h={color:e,opacity:t,transparent:r,screenspace:o,toneMapped:i,polygonOffset:s,polygonOffsetFactor:l,renderOrder:c,thickness:u,angle:d};function p(e){const t=f.parent;if(f.clear(),t&&t.geometry){let r;const o=new T({side:a.BackSide});t.skeleton?(r=new a.SkinnedMesh,r.material=o,r.bind(t.skeleton,t.bindMatrix),f.add(r)):t.isInstancedMesh?(r=new a.InstancedMesh(t.geometry,o,t.count),r.instanceMatrix=t.instanceMatrix,f.add(r)):(r=new a.Mesh,r.material=o,f.add(r)),r.geometry=e?n.toCreasedNormals(t.geometry,e):t.geometry}}function v(e){h={...h,...e};const t=f.children[0];if(t){const{transparent:e,thickness:n,color:r,opacity:o,screenspace:i,toneMapped:s,polygonOffset:l,polygonOffsetFactor:c,renderOrder:u}=h,d=new a.Vector2;!m&&h.screenspace&&console.warn('Outlines: "screenspace" requires a WebGLRenderer instance to calculate the outline size'),m&&m.getSize(d),Object.assign(t.material,{transparent:e,thickness:n,color:r,opacity:o,size:d,screenspace:i,toneMapped:s,polygonOffset:l,polygonOffsetFactor:c}),void 0!==u&&(t.renderOrder=u)}}return{group:f,updateProps(e){var t;const n=null!==(t=e.angle)&&void 0!==t?t:h.angle;n!==h.angle&&p(n),v(e)},generate(){p(h.angle),v(h)}}},exports.ProgressiveLightMap=class{constructor(e,t,n=1024){this.renderer=e,this.res=n,this.scene=t,this.buffer1Active=!1,this.lights=[],this.meshes=[],this.object=null,this.clearColor=new a.Color,this.clearAlpha=0;const r=/(Android|iPad|iPhone|iPod)/g.test(navigator.userAgent)?a.HalfFloatType:a.FloatType;this.progressiveLightMap1=new a.WebGLRenderTarget(this.res,this.res,{type:r}),this.progressiveLightMap2=new a.WebGLRenderTarget(this.res,this.res,{type:r}),this.discardMat=new f,this.targetMat=new a.MeshLambertMaterial({fog:!1}),this.previousShadowMap={value:this.progressiveLightMap1.texture},this.averagingWindow={value:100},this.targetMat.onBeforeCompile=e=>{e.vertexShader="varying vec2 vUv;\n"+e.vertexShader.slice(0,-1)+"vUv = uv; gl_Position = vec4((uv - 0.5) * 2.0, 1.0, 1.0); }";const t=e.fragmentShader.indexOf("void main() {");e.fragmentShader="varying vec2 vUv;\n"+e.fragmentShader.slice(0,t)+"uniform sampler2D previousShadowMap;\n\tuniform float averagingWindow;\n"+e.fragmentShader.slice(t-1,-1)+"\nvec3 texelOld = texture2D(previousShadowMap, vUv).rgb;\n        gl_FragColor.rgb = mix(texelOld, gl_FragColor.rgb, 1.0/ averagingWindow);\n      }",e.uniforms.previousShadowMap=this.previousShadowMap,e.uniforms.averagingWindow=this.averagingWindow}}clear(){this.renderer.getClearColor(this.clearColor),this.clearAlpha=this.renderer.getClearAlpha(),this.renderer.setClearColor("black",1),this.renderer.setRenderTarget(this.progressiveLightMap1),this.renderer.clear(),this.renderer.setRenderTarget(this.progressiveLightMap2),this.renderer.clear(),this.renderer.setRenderTarget(null),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.lights=[],this.meshes=[],this.scene.traverse((e=>{!function(e){return!!e.geometry}(e)?function(e){return e.isLight}(e)&&this.lights.push({object:e,intensity:e.intensity}):this.meshes.push({object:e,material:e.material})}))}prepare(){this.lights.forEach((e=>e.object.intensity=0)),this.meshes.forEach((e=>e.object.material=this.discardMat))}finish(){this.lights.forEach((e=>e.object.intensity=e.intensity)),this.meshes.forEach((e=>e.object.material=e.material))}configure(e){this.object=e}update(e,t=100){if(!this.object)return;this.averagingWindow.value=t,this.object.material=this.targetMat;const n=this.buffer1Active?this.progressiveLightMap1:this.progressiveLightMap2,r=this.buffer1Active?this.progressiveLightMap2:this.progressiveLightMap1,o=this.scene.background;this.scene.background=null,this.renderer.setRenderTarget(n),this.previousShadowMap.value=r.texture,this.buffer1Active=!this.buffer1Active,this.renderer.render(this.scene,e),this.renderer.setRenderTarget(null),this.scene.background=o}},exports.SoftShadowMaterial=h,exports.Splat=z,exports.SplatLoader=B,exports.SpotLightMaterial=I,exports.SpriteAnimator=({startFrame:e,endFrame:t,fps:n,frameName:r,textureDataURL:o,textureImageURL:i,loop:s,numberOfFrames:l,autoPlay:c,animationNames:u,onStart:d,onEnd:m,onLoopEnd:f,onFrame:h,play:p,pause:v,flipX:g,alphaTest:x,asSprite:w})=>{let y={frames:[],meta:{version:"1.0",size:{w:1,h:1},scale:"1"}},S=!1,M=new a.Texture;const _=new a.SpriteMaterial({toneMapped:!1,transparent:!0,map:M,alphaTest:null!=x?x:0}),D=new a.MeshBasicMaterial({toneMapped:!1,side:a.DoubleSide,map:M,transparent:!0,alphaTest:null!=x?x:0}),b=new a.Sprite(_),T=new a.Mesh(new a.PlaneGeometry(1,1),D);let P=_,C=b;const F=new a.Group;F.add(C);let A=window.performance.now(),B=e||0,U=r||"";const z=1e3/(n||30),R=new a.Vector3(1,1,1),k=e=>{R.copy(e)},I=g?-1:1;let V=null==w||w;V=V,V?(P=_,C=b,F.add(b),F.remove(T)):(P=D,C=T,F.remove(b),F.add(T));const O=(e,t)=>{const n=t/e;return C.scale.set(1,n,1),C.scale},N=(e,t)=>{if(null===e){if(t&&l){const e=t.image.width,n=t.image.height,r=e/l,o=n;if(y={frames:[],meta:{version:"1.0",size:{w:e,h:n},scale:"1"}},parseInt(r.toString(),10)===r)for(let e=0;e<l;e++)y.frames.push({frame:{x:e*r,y:0,w:r,h:o},rotated:!1,trimmed:!1,spriteSourceSize:{x:0,y:0,w:r,h:o},sourceSize:{w:r,h:n}})}}else if(t){y=e,y.frames=Array.isArray(e.frames)?e.frames:E();const{w:n,h:r}=L(e.frames).sourceSize,o=O(n,r);k(o),P&&(P.map=t)}var n;t.premultiplyAlpha=!1,M=n=t,P&&(P.map=n),j()},E=()=>{const e={},t=y,n=u;if(n)for(let r=0;r<n.length;r++){e[n[r]]=[];for(const o in t.frames){const a=t.frames[o],i=a.frame,s=i.x,l=i.y,c=i.w,u=i.h,d=a.sourceSize.w,m=a.sourceSize.h;"string"==typeof o&&-1!==o.toLowerCase().indexOf(n[r].toLowerCase())&&e[n[r]].push({x:s,y:l,w:c,h:u,frame:i,sourceSize:{w:d,h:m}})}}return e},j=()=>{if(!y||!P.map)return;const{meta:{size:e},frames:t}=y,{w:n,h:o}=Array.isArray(t)?t[0].sourceSize:r&&t[r]?t[r][0].sourceSize:{w:0,h:0};P.map.wrapS=P.map.wrapT=a.RepeatWrapping,P.map.center.set(0,0),P.map.repeat.set(1*I/(e.w/n),1/(e.h/o));const i=1/((e.h-1)/o);P.map.offset.x=0,P.map.offset.y=1-i,d&&d({currentFrameName:r,currentFrame:B})},L=e=>{if(Array.isArray(e))return e[0];if("object"==typeof e&&null!==e){return e[Object.keys(e)[0]][0]}return{w:0,h:0}};return{group:F,init:async()=>{if(o&&i)await async function(e,t,n){const r=new a.TextureLoader,o=fetch(e).then((e=>e.json())),i=new Promise((e=>{r.load(t,e)}));await Promise.all([o,i]).then((e=>{n(e[0],e[1])}))}(o,i,N);else if(i){const e=new a.TextureLoader,t=await e.loadAsync(i);N(null,t)}},update:()=>{var n,o;null!=(n=y)&&n.frames&&null!=(o=P)&&o.map&&(v||S||!c&&!p||((()=>{if(!y||!P.map)return;const n=window.performance.now(),o=n-A,{meta:{size:a},frames:i}=y,{w:l,h:c}=L(i).sourceSize,u=Array.isArray(i)?i:r?i[r]:[];let d=0,h=0;const p=t||u.length-1;if(B>p&&(B=s&&null!=e?e:0,s?null==f||f({currentFrameName:r,currentFrame:B}):(null==m||m({currentFrameName:r,currentFrame:B}),S=!0),!s))return;if(o<=z)return;A=n-o%z,O(l,c);const v=(a.w-1)/l,g=(a.h-1)/c,{frame:{x:x,y:w},sourceSize:{w:M,h:_}}=u[B],D=1/v,b=1/g;d=I>0?D*(x/M):D*(x/M)-P.map.repeat.x,h=Math.abs(1-b)-b*(w/_),P.map.offset.x=d,P.map.offset.y=h,B+=1})(),h&&h({currentFrameName:U,currentFrame:B})))},playAnimation:()=>{p=!0,v=!1},pauseAnimation:()=>{v=!0},setFrameName:e=>{U!==(r=e)&&r&&(B=0,U=r)}}},exports.Text=({sdfGlyphSize:e=64,anchorX:t="center",anchorY:n="middle",fontSize:o=1,...a})=>{const i={sdfGlyphSize:e,anchorX:t,anchorY:n,fontSize:o,...a},s=new r.Text;return Object.assign(s,C(i)),i.font&&i.characters&&r.preloadFont({font:i.font,characters:i.characters},(()=>{i.onPreloadEnd&&i.onPreloadEnd()})),{mesh:s,updateProps(e){Object.assign(s,C(e)),s.sync((()=>{i.onSync&&i.onSync(s)}))},dispose(){s.dispose()}}},exports.pcss=({focus:e=0,size:t=25,samples:n=10}={})=>{const r=a.ShaderChunk.shadowmap_pars_fragment;return a.ShaderChunk.shadowmap_pars_fragment=a.ShaderChunk.shadowmap_pars_fragment.replace("#ifdef USE_SHADOWMAP",`#ifdef USE_SHADOWMAP\n\n    #define PENUMBRA_FILTER_SIZE float(${t})\n    #define RGB_NOISE_FUNCTION(uv) (randRGB(uv))\n    vec3 randRGB(vec2 uv) {\n      return vec3(\n        fract(sin(dot(uv, vec2(12.75613, 38.12123))) * 13234.76575),\n        fract(sin(dot(uv, vec2(19.45531, 58.46547))) * 43678.23431),\n        fract(sin(dot(uv, vec2(23.67817, 78.23121))) * 93567.23423)\n      );\n    }\n    \n    vec3 lowPassRandRGB(vec2 uv) {\n      // 3x3 convolution (average)\n      // can be implemented as separable with an extra buffer for a total of 6 samples instead of 9\n      vec3 result = vec3(0);\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(-1.0, +1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2( 0.0, +1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, -1.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0,  0.0));\n      result += RGB_NOISE_FUNCTION(uv + vec2(+1.0, +1.0));\n      result *= 0.111111111; // 1.0 / 9.0\n      return result;\n    }\n    vec3 highPassRandRGB(vec2 uv) {\n      // by subtracting the low-pass signal from the original signal, we're being left with the high-pass signal\n      // hp(x) = x - lp(x)\n      return RGB_NOISE_FUNCTION(uv) - lowPassRandRGB(uv) + 0.5;\n    }\n    \n    \n    vec2 vogelDiskSample(int sampleIndex, int sampleCount, float angle) {\n      const float goldenAngle = 2.399963f; // radians\n      float r = sqrt(float(sampleIndex) + 0.5f) / sqrt(float(sampleCount));\n      float theta = float(sampleIndex) * goldenAngle + angle;\n      float sine = sin(theta);\n      float cosine = cos(theta);\n      return vec2(cosine, sine) * r;\n    }\n    float penumbraSize( const in float zReceiver, const in float zBlocker ) { // Parallel plane estimation\n      return (zReceiver - zBlocker) / zBlocker;\n    }\n    float findBlocker(sampler2D shadowMap, vec2 uv, float compare, float angle) {\n      float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n      float blockerDepthSum = float(${e});\n      float blockers = 0.0;\n    \n      int j = 0;\n      vec2 offset = vec2(0.);\n      float depth = 0.;\n    \n      #pragma unroll_loop_start\n      for(int i = 0; i < ${n}; i ++) {\n        offset = (vogelDiskSample(j, ${n}, angle) * texelSize) * 2.0 * PENUMBRA_FILTER_SIZE;\n        depth = unpackRGBAToDepth( texture2D( shadowMap, uv + offset));\n        if (depth < compare) {\n          blockerDepthSum += depth;\n          blockers++;\n        }\n        j++;\n      }\n      #pragma unroll_loop_end\n    \n      if (blockers > 0.0) {\n        return blockerDepthSum / blockers;\n      }\n      return -1.0;\n    }\n            \n    float vogelFilter(sampler2D shadowMap, vec2 uv, float zReceiver, float filterRadius, float angle) {\n      float texelSize = 1.0 / float(textureSize(shadowMap, 0).x);\n      float shadow = 0.0f;\n      int j = 0;\n      vec2 vogelSample = vec2(0.0);\n      vec2 offset = vec2(0.0);\n      #pragma unroll_loop_start\n      for (int i = 0; i < ${n}; i++) {\n        vogelSample = vogelDiskSample(j, ${n}, angle) * texelSize;\n        offset = vogelSample * (1.0 + filterRadius * float(${t}));\n        shadow += step( zReceiver, unpackRGBAToDepth( texture2D( shadowMap, uv + offset ) ) );\n        j++;\n      }\n      #pragma unroll_loop_end\n      return shadow * 1.0 / ${n}.0;\n    }\n    \n    float PCSS (sampler2D shadowMap, vec4 coords) {\n      vec2 uv = coords.xy;\n      float zReceiver = coords.z; // Assumed to be eye-space z in this code\n      float angle = highPassRandRGB(gl_FragCoord.xy).r * PI2;\n      float avgBlockerDepth = findBlocker(shadowMap, uv, zReceiver, angle);\n      if (avgBlockerDepth == -1.0) {\n        return 1.0;\n      }\n      float penumbraRatio = penumbraSize(zReceiver, avgBlockerDepth);\n      return vogelFilter(shadowMap, uv, zReceiver, 1.25 * penumbraRatio, angle);\n    }`).replace("#if defined( SHADOWMAP_TYPE_PCF )","\nreturn PCSS(shadowMap, shadowCoord);\n#if defined( SHADOWMAP_TYPE_PCF )"),(e,t,n)=>{a.ShaderChunk.shadowmap_pars_fragment=r,function(e,t,n){t.traverse((t=>{t.material&&(Array.isArray(t.material)?t.material.forEach((t=>{e.properties.remove(t),t.dispose()})):(e.properties.remove(t.material),t.material.dispose()))})),e.info.programs.length=0,e.compile(t,n)}(e,t,n)}},exports.shaderMaterial=i,exports.useFBO=s;
